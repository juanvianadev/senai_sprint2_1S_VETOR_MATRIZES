# -*- coding: utf-8 -*-
"""SENAI-Python-Lista-Atividades-6-MATRIZES_VETORES.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19nhw6dpwB9otM8qkcE7X04_ONqkLNiXb
"""

import numpy as np

"""## 1. Crie um vetor numpy com os números pares de 1 a 20. Dica: use np.arange()"""

np.arange(2, 21, 2, dtype=int)

"""## 2. Crie uma matriz numpy 3x3 com valores aleatórios entre 0 e 10. Dica: use np.random.rand()"""

np.random.uniform(low = 0, high = 10, size=(3,3))

"""## 3. Multiplique todos os elementos de um vetor por 2. Use broadcasting para evitar loop.
##Exemplo: Seja `vetor = np.array([1, 2, 3, 4])`. O resultado esperado: `array([2, 4, 6, 8])`
"""

vetor = np.array([1, 2, 3, 4])

print(vetor * 2)

"""## 4. Calcule a soma cumulativa de um vetor. Dica: usar np.cumsum()
## Exemplo: Seja `vetor = np.array([1, 2, 3, 4])`, o resultado seria `array([ 1, 3, 6, 10])`
"""

vetor = np.array([1, 2, 3, 4])
np.cumsum(vetor)

"""## 5. Transponha uma matriz.
## Exemplo: Seja `matriz = np.array([[1, 2], [3, 4], [5, 6]])`, o resultado seria `array([[1, 3,5], [2, 4, 6]])`
"""

matriz = np.array([[1, 2], [3, 4], [5, 6]])
print(matriz)
print()
matriz_transp = np.transpose(matriz)
print(matriz_transp)

"""## 6. Converta uma matriz em um vetor unidimensional.
## Exemplo: Seja `matriz = np.array([[1, 2, 3], [4, 5, 6]])`, o resultado seria `array([1, 2, 3,4, 5, 6])`
"""

matriz = np.array([[1, 2, 3], [4, 5, 6]])
matriz.flatten()

"""## 7. Multiplicação matricial: multiplique uma matriz (m × n) por um vetor (n × 1).
## Exemplo: Seja `matriz = np.array([[1, 2], [3, 4]])` e `vetor = np.array([[5], [6]])`, o resultado seria `array([[17], [39]])`
"""

matriz = np.array([[1, 2], [3, 4]])
vetor = np.array([[5], [6]])

matriz @ vetor

"""## 8. Encontre os índices dos valores máximos em cada linha de uma matriz. Dica: use np.argmax(). Exemplo: Seja `matriz = np.array([[1, 9, 6], [8, 2, 3], [4, 7, 5]])`, o resultado seria `array([1, 0, 1])`"""

matriz = np.array([[1, 9, 6], [8, 2, 3], [4, 7, 5]])
#Eixo ao longo do qual é calculada a média aritmética.
#axis=0 significa média aritmética computada ao longo da coluna,
#axis=1 significa média aritmética ao longo da linha.
#Trata a matriz de múltiplas dimensões como uma lista achatada se o axis não for dado.
np.argmax(matriz, axis=1)

"""## 9. Calcule a raiz quadrada de todos os elementos de um vetor.
## Exemplo: Seja `vetor = np.array([4, 9, 16, 25])`, o resultado seria `array([2., 3., 4., 5.])`
"""

vetor = np.array([4, 9, 16, 25])
np.sqrt(vetor)

"""## 10. Substitua todos os valores negativos em um vetor por 0. Exemplo: Seja `vetor = np.array([-1, 2, -3, 4, -5])`, o resultado seria `array([0, 2, 0, 4, 0])`"""

vetor = np.array([-1, 2, -3, 4, -5])
result = np.where(vetor<0, 0, vetor)
print("New resulting array: ", result)

"""## 11. Reshape um vetor unidimensional em uma matriz 3x3. Exemplo: Seja `vetor = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])`, o resultado seria `array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])`"""

vetor = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
np.reshape(vetor, (3, 3))

"""## 12. Adicione um valor constante a todos os elementos de um vetor.
## Exemplo: Seja `vetor = np.array([1, 2, 3, 4])` e `constante = 5`, o resultado seria `array([6, 7, 8, 9])`
"""

vetor = np.array([1, 2, 3, 4])
vetor + 5

"""## 13. Determine uma constante que ao multiplicar todos os elementos de uma matriz por essa constante, a soma dos elementos da matriz resultante será 1. Não usar loops.
## Exemplo: Seja `matriz = np.array([[1, 2], [3, 4]])`, o resultado seria `array([[0.1, 0.2], [0.3, 0.4]])`, pois 0.1+0.2+0.3+0.4 = 1.
"""

matriz = np.array([[1, 2], [3, 4]])
matriz * 0.1

"""## 14. Gere uma matriz identidade 3x3. Dica: use np.eye()"""

np.eye(3,3)

"""## 15. Concatene duas matrizes horizontalmente. Dica: use np.hstack()
Exemplo:


"""

matriz1 = np.array([[1, 2, 3], [4, 5, 6]])
matriz2 = np.array([[7, 8, 9], [10, 11, 12]])
np.hstack((matriz1, matriz2))

"""## 16. Encontre o produto escalar entre os vetores [1, 2, 3] e [4, 5, 6]. Dica: use np.dot() e também o operador @ para conferir o outro resultado"""

vetor1 =  np.array([1, 2, 3])
vetor2 =  np.array([4, 5, 6])

print(np.dot(vetor1, vetor2))
print(vetor1 @ vetor2)

"""## 17. Calcule a média e o desvio padrão de cada linha de uma matriz. Dica: use np.mean() e np.std(). Exemplo: `matriz = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])`. O resultado deve ser: média por linha: [2. 5. 8.], desvio padrão por linha: [0.8165, 0.8165, 0.8165]"""

matriz = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(np.mean(matriz, axis=1))
print(np.std(matriz, axis=1))

"""## 18. Calcule a média e o desvio padrão de cada coluna de uma matriz. Dica: use np.mean() e np.std(). Exemplo: matriz = `np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])`. O resultado deve ser: média por coluna: `[4. 5. 6.]`, desvio padrão por coluna: `[2.4495, 2.4495, 2.4495]`"""

matriz = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(np.mean(matriz, axis=0))
print(np.std(matriz, axis=0))

"""## 19. Calcule a média de cada coluna de uma matriz e a subtraia da respectiva coluna.
## Exemplo: Seja `matriz = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])`, o resultado seria `array([[-3., -3., -3.], [ 0., 0., 0.], [ 3., 3., 3.]])`. Use broadcasting para evitar loops
"""

matriz = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
mediaMatriz = np.mean(matriz, axis=0)
matriz - mediaMatriz

"""## 20. Calcule a média de cada linha de uma matriz e a subtraia da respectiva linha.
## Exemplo: Seja `matriz = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])`, o resultado seria `array([[-1., 0., 1.], [-1., 0., 1.], [-1., 0., 1.]])`. Use broadcasting para evitar loops
"""

matriz = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
mediaMatriz = np.mean(matriz, axis=1)
matrizT = np.transpose(matriz)
resultado = matrizT - mediaMatriz
np.transpose(resultado)

"""## 21. Uma operação comum em ciência de dados ou aprendizado de máquina é a normalização dos dados. Os dados estão dispostos em uma matriz e cada característica de interesse ao longo das colunas. Por exemplo, uma matriz em que cada linha corresponde a uma pessoa, teremos a coluna das idades, a coluna das alturas, a coluna da renda mensal, etc. A normalização consiste em, para cada ponto na matriz, subtrair a média da coluna e dividir pelo desvio padrão da respectiva coluna. Normalize os dados da seguinte matriz X, onde cada linha corresponde a uma amostra (e.g. pessoa) e cada coluna corresponde a uma característica dela. Para normalizar os dados, você pode usar broadcasting para subtrair a média de cada coluna e dividir pelo desvio padrão, evitando a necessidade de loops explícitos. Dica: use os métodos mean(), std() para os cálculos da média e desvio padrão, respectivamente.

`X = [[ 55 1.72 603 ]
[ 54 1.42 646 ]
[ 44 1.89 964 ]
[ 38 1.79 529 ]]`



`[[ 1.023 0.086 -0.497]
[ 0.882 -1.626 -0.238]
[-0.529 1.055 1.676]
[-1.376 0.485 -0.942]]`
"""

matriz = np.array([[ 55, 1.72, 603 ],
                   [ 54, 1.42, 646 ],
                   [ 44, 1.89, 964 ],
                   [ 38, 1.79, 529 ]])

mediaMatriz = np.mean(matriz, axis=0)
desvioPadraoMatriz = np.std(matriz)
mediaMatriz / desvioPadraoMatriz

"""## 22. Encontre a solução para o seguinte problema. Arredondar todos os valores em uma matriz para o inteiro mais próximo. Dica: analise np.floor(), np.ceil(), np.fix() e np.round()
## Exemplo:
"""

matriz = np.array([[1.2, 2.8, 3.5],
                   [4.9, 5.1, 6.7],
                   [7.3, 8.6, 9.2]])

np.floor(matriz)
np.ceil(matriz)
np.fix(matriz)
np.round(matriz)

"""## 23. Dada a matriz A, encontre sua inversa A^−1. Então, conprove que A A^−1 = I, onde I é a matriz identidade, com elementos da diagonal unitários e o restante zero."""

matriz = np.array([[1, 3, 2],
                   [5, 4, 6],
                   [7, 9, 8]])

I = np.eye(3,3)

matrizInversa = np.linalg.inv(matriz)

resultado = matriz @ matrizInversa

print(np.abs(resultado))

"""## 24. Suponha que você seja um corretor imobiliário e deseja prever o preço de uma casa com base em diferentes características, como área construída, número de quartos, número de banheiros e idade da casa. Você coletou dados de venda de casas nos últimos seis meses e registrou essas características para cada venda. Os dados coletados estão disponíveis na forma de uma matriz, onde cada linha representa uma casa vendida e cada coluna representa uma característica. Além disso, você tem um vetor com os preços de venda correspondentes das casas.
## Tarefa:
## Encontrar os coeficientes ideais que relacionam as características das casas com os preços de venda. Em seguida, preveja o preço de uma nova casa com as seguintes características:
• Área construída: 180 metros quadrados
• Número de quartos: 3
• Número de banheiros: 2
• Idade da casa: 10 anos
`(Resposta: 355000)`
"""

casas = np.array([[ 150, 3, 2, 5 ], [ 200, 4, 3, 7 ], [ 180, 3, 2, 10 ], [ 170, 3, 2, 10 ], [ 220, 4, 3, 8 ], [ 190, 3, 2, 6 ]])
casaNova = np.array([[ 180, 3, 2, 10 ]])
valores = np.array([ 300000, 400000, 350000, 250000, 420000, 380000])

X, residuals, _, _ = np.linalg.lstsq(casas, valores, rcond=None)

print("X:", np.round(X,2))

estimado = casas @ X
estimadoNova = casaNova @ X
diferenca = (estimado - valores) / valores
print("Estimado:", np.round(estimado, 2))
print("Estimado Casa Nova:", np.round(estimadoNova, 2))
print("Real:", valores)
print("(Estimado - Real)/Real:", diferenca)